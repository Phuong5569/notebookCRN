{% load static %}
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Multi-Page Notebook Canvas Drawing Tool</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="{% static 'notebook/style.css' %}"
    />
    <style>
      .canvas-wrapper,
      .canvas-container {
        width: 100vw;
        height: 100vh;
        position: relative;
        overflow: hidden;
      }

      canvas {
        display: block;
        position: absolute;
        top: 0;
        left: 0;
      }

      .canvas-container {
        width: 100%;
        max-width: 595px; /* optional: prevent overflow */
        margin: auto;
        position: relative;
      }

      .page-controls {
        display: flex;
        align-items: center;
        gap: 15px;
        margin: 10px 0;
        padding: 10px;
        background: #f5f5f5;
        border-radius: 8px;
        border: 1px solid #ddd;
      }

      .page-nav {
        display: flex;
        align-items: center;
        gap: 10px;
      }

      .page-btn {
        padding: 8px 12px;
        border: 1px solid #007bff;
        background: #007bff;
        color: white;
        border-radius: 4px;
        cursor: pointer;
        font-size: 14px;
        transition: background-color 0.2s;
      }

      .page-btn:hover:not(:disabled) {
        background: #0056b3;
      }

      .page-btn:disabled {
        background: #ccc;
        border-color: #ccc;
        cursor: not-allowed;
      }

      .page-info {
        display: flex;
        align-items: center;
        gap: 10px;
        font-weight: bold;
        color: #333;
      }

      .page-input {
        width: 60px;
        padding: 4px 8px;
        border: 1px solid #ddd;
        border-radius: 4px;
        text-align: center;
        font-size: 14px;
      }

      .page-thumbnails {
        display: flex;
        gap: 10px;
        padding: 10px 0;
        overflow-x: auto;
        border-top: 1px solid #ddd;
        margin-top: 10px;
      }

      .page-thumbnail {
        flex-shrink: 0;
        width: 80px;
        height: 100px;
        border: 2px solid #ddd;
        border-radius: 4px;
        cursor: pointer;
        position: relative;
        background: white;
      }

      .page-thumbnail.active {
        border-color: #007bff;
        box-shadow: 0 0 5px rgba(0, 123, 255, 0.5);
      }

      .page-thumbnail canvas {
        width: 100%;
        height: 100%;
        border-radius: 2px;
      }

      .page-number {
        position: absolute;
        bottom: 2px;
        left: 2px;
        background: rgba(0, 0, 0, 0.7);
        color: white;
        font-size: 10px;
        padding: 2px 4px;
        border-radius: 2px;
      }

      .delete-page {
        position: absolute;
        top: 2px;
        right: 2px;
        background: #dc3545;
        color: white;
        border: none;
        width: 16px;
        height: 16px;
        border-radius: 50%;
        font-size: 10px;
        cursor: pointer;
        display: none;
      }

      .page-thumbnail:hover .delete-page {
        display: block;
      }

      .book-info {
        display: flex;
        align-items: center;
        gap: 10px;
        margin-bottom: 10px;
      }

      .book-title {
        font-size: 18px;
        font-weight: bold;
        color: #333;
      }

      .book-actions {
        display: flex;
        gap: 10px;
      }

      .export-all-btn {
        background: #28a745;
        color: white;
        border: 1px solid #28a745;
        padding: 8px 16px;
        border-radius: 4px;
        cursor: pointer;
        font-size: 14px;
      }

      .export-all-btn:hover {
        background: #218838;
      }

      .toolbar {
        position: fixed;
        top: 80px;
        left: 0;
        width: 60px;
        height: calc(100% - 100px);
        background: #f8f9fa;
        border-right: 1px solid #ccc;
        padding: 10px 5px;
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 10px;
        transition: transform 0.3s ease-in-out;
        z-index: 998;
      }

      .toolbar.hidden {
        transform: translateX(-100%);
      }

      .tool-btn {
        background: none;
        border: none;
        font-size: 20px;
        cursor: pointer;
        padding: 5px;
        width: 40px;
        height: 40px;
        display: flex;
        align-items: center;
        justify-content: center;
        border-radius: 6px;
        transition: background 0.2s;
      }

      .tool-btn.active,
      .tool-btn:hover:not(:disabled) {
        background: #007bff;
        color: white;
      }

      .tool-btn:disabled {
        opacity: 0.4;
        cursor: not-allowed;
      }

      .tool-options {
        margin-top: 20px;
        display: flex;
        flex-direction: column;
        gap: 10px;
        align-items: center;
        width: 100%;
        font-size: 12px;
        text-align: center;
      }
      .pen-size-container {
        display: flex;
        flex-direction: column;
        align-items: center;
        height: 150px;
        gap: 5px;
      }

      .pen-size-container input[type="range"] {
        writing-mode: bt-lr; /* vertical from bottom to top */
        -webkit-appearance: slider-vertical;
        width: 30px;
        height: 120px;
        padding: 0;
        margin: 0;
      }

      #size-display {
        font-size: 12px;
        margin-top: 5px;
      }

      .size-icon {
        font-size: 20px;
      }
      .floating-btn {
        position: fixed;
        top: 10px;
        z-index: 10000;
        background: #007bff;
        color: white;
        padding: 10px 14px;
        border-radius: 8px;
        font-size: 16px;
        border: none;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        cursor: pointer;
      }

      .left-btn {
        left: 10px;
      }

      .right-btn {
        right: 10px;
      }

      .dropdown-menu {
        position: fixed;
        top: 60px;
        left: 10px;
        width: calc(100% - 20px);
        max-width: 400px;
        background: white;
        border-radius: 12px;
        box-shadow: 0 8px 20px rgba(0, 0, 0, 0.15);
        padding: 15px;
        z-index: 9999;
        transition: opacity 0.3s ease, transform 0.2s ease;
      }

      .dropdown-menu.hidden {
        display: none;
      }

      .menu-section {
        margin-bottom: 15px;
      }

      .menu-section h3 {
        font-size: 16px;
        margin-bottom: 8px;
        color: #333;
      }

      .menu-btn {
        background: #f1f1f1;
        border: none;
        padding: 8px 12px;
        border-radius: 6px;
        font-size: 14px;
        cursor: pointer;
        transition: background 0.2s;
      }

      .menu-btn:hover {
        background: #e0e0e0;
      }

      .menu-btn.danger {
        background: #dc3545;
        color: white;
      }

      .menu-btn.danger:hover {
        background: #c82333;
      }

      .menu-input {
        width: 50px;
        text-align: center;
        padding: 6px;
        border: 1px solid #ccc;
        border-radius: 6px;
      }
    </style>
  </head>
  <body>
    {% csrf_token %}
    <button
      id="toggle-toolbar-btn"
      class="page-btn"
      style="position: fixed; top: 20px; left: 20px; z-index: 999"
    >
      üõ†Ô∏è
    </button>
    <!-- Buttons -->
    <button id="toggle-top-menu-btn" class="floating-btn right-btn">
      ‚ò∞ Menu
    </button>

    <!-- Dropdown-style menu -->
    <div id="top-menu" class="dropdown-menu hidden">
      <div class="menu-section">
        <h3>Book Actions</h3>
        <button id="export-all-btn" class="menu-btn">
          üì§ Export All Pages
        </button>
        <a href="/notebook/" class="menu-btn">üè† Back to Home</a>
      </div>

      <hr />

      <div class="menu-section">
        <h3>Page Controls</h3>
        <div style="display: flex; gap: 10px; flex-wrap: wrap">
          <button id="prev-page" class="menu-btn">‚Üê Prev</button>
          <input
            type="number"
            id="current-page-input"
            class="menu-input"
            value="1"
            min="1"
          />
          <span id="total-pages">1</span>
          <button id="next-page" class="menu-btn">Next ‚Üí</button>
        </div>
        <div
          style="margin-top: 10px; display: flex; gap: 10px; flex-wrap: wrap"
        >
          <button id="add-page" class="menu-btn">‚ûï Add Page</button>
          <button id="duplicate-page" class="menu-btn">üìÑ Duplicate</button>
          <button id="delete-page" class="menu-btn danger">üóë Delete</button>
        </div>
      </div>
    </div>

    <div class="toolbar" id="toolbar">
      <button id="pen-tool" class="tool-btn active" title="Pen">üñäÔ∏è</button>
      <button id="eraser-tool" class="tool-btn" title="Eraser">üßΩ</button>
      <button id="undo-btn" class="tool-btn" title="Undo">‚Ü©Ô∏è</button>
      <button id="clear-btn" class="tool-btn" title="Clear">üóëÔ∏è</button>
      <button id="download-btn" class="tool-btn" title="Download">‚¨áÔ∏è</button>
      <button id="convert-btn" class="tool-btn" title="Convert">üîÅ</button>
      <button
        id="extract-text-btn"
        class="tool-btn"
        disabled
        title="Extract Text"
      >
        üî§
      </button>

      <div class="tool-options">
        <label title="Pen Color">
          üé® <input type="color" id="pen-color" value="#000000" />
        </label>
        <div class="pen-size-container" title="Pen Size">
          <span class="size-icon">üìè</span>
          <input
            type="range"
            id="pen-size"
            min="1"
            max="20"
            value="2"
            orient="vertical"
          />
          <span id="size-display">2px</span>
        </div>
      </div>
    </div>

    <div class="canvas-container">
      <canvas id="background-canvas"></canvas>
      <canvas id="drawing-canvas"></canvas>
    </div>

    <div class="page-thumbnails" id="page-thumbnails">
      <!-- Thumbnails will be generated here -->
    </div>

    <div class="status-bar">
      <span id="tool-status">Current tool: Pen</span>
      <span> | Press Ctrl+Z for undo</span>
      <span id="convert-status"></span>
    </div>

    <script>
      const urlParams = new URLSearchParams(window.location.search);
      const bookId = urlParams.get("book"); // ?book=my-book
      // Canvas setup
      const drawingCanvas = document.getElementById("drawing-canvas");
      const backgroundCanvas = document.getElementById("background-canvas");
      const drawingCtx = drawingCanvas.getContext("2d");
      const bgCtx = backgroundCanvas.getContext("2d");
      const backgroundCtx = backgroundCanvas.getContext("2d");

      // Set canvas dimensions (A4 size at 72 DPI)
      const canvasWidth = 595;
      const canvasHeight = 842;

      function resizeCanvasForDisplay() {
        // Keep internal resolution
        drawingCanvas.width = canvasWidth;
        drawingCanvas.height = canvasHeight;
        backgroundCanvas.width = canvasWidth;
        backgroundCanvas.height = canvasHeight;

        // Fit visually to screen
        const screenWidth = window.innerWidth;
        const scale = Math.min(screenWidth / canvasWidth, 1); // Don't upscale above 100%
        drawingCanvas.style.width = canvasWidth * scale + "px";
        drawingCanvas.style.height = canvasHeight * scale + "px";
        backgroundCanvas.style.width = canvasWidth * scale + "px";
        backgroundCanvas.style.height = canvasHeight * scale + "px";
      }

      // Tool elements
      const penTool = document.getElementById("pen-tool");
      const eraserTool = document.getElementById("eraser-tool");
      const clearBtn = document.getElementById("clear-btn");
      const downloadBtn = document.getElementById("download-btn");
      const undoBtn = document.getElementById("undo-btn");
      const convertBtn = document.getElementById("convert-btn");
      const extractTextBtn = document.getElementById("extract-text-btn");
      const penColor = document.getElementById("pen-color");
      const penSize = document.getElementById("pen-size");
      const sizeDisplay = document.getElementById("size-display");
      const toolStatus = document.getElementById("tool-status");
      const convertStatus = document.getElementById("convert-status");

      // Page control elements
      const prevPageBtn = document.getElementById("prev-page");
      const nextPageBtn = document.getElementById("next-page");
      const addPageBtn = document.getElementById("add-page");
      const duplicatePageBtn = document.getElementById("duplicate-page");
      const deletePageBtn = document.getElementById("delete-page");
      const currentPageInput = document.getElementById("current-page-input");
      const totalPagesSpan = document.getElementById("total-pages");
      const pageThumbnailsContainer =
        document.getElementById("page-thumbnails");
      const exportAllBtn = document.getElementById("export-all-btn");

      // Multi-page state
      let pages = [];
      let currentPageIndex = 0;
      let pageHistory = []; // History for each page

      // Drawing state
      let isDrawing = false;
      let currentTool = "pen";
      let lastX = 0;
      let lastY = 0;
      const lineSpacing = 90;
      let lastConversionData = null;

      async function initializeNotebook() {
        if (!bookId) {
          alert("Missing book ID in URL!");
          return;
        }

        const response = await fetch(`/api/book/${bookId}/`);
        const book = await response.json();

        if (!book.pages || book.pages.length === 0) {
          // Start with page 1 if none exist
          pages.push({
            id: 1,
            drawingData: null,
            history: [],
            currentStep: -1,
          });
        } else {
          for (const pageId of book.pages) {
            const img = new Image();
            img.src = `/media/book_storage/${bookId}/page-${pageId}.png`;

            await new Promise((resolve) => {
              img.onload = () => {
                const tempCanvas = document.createElement("canvas");
                tempCanvas.width = canvasWidth;
                tempCanvas.height = canvasHeight;
                const tempCtx = tempCanvas.getContext("2d");

                // Draw image to temp canvas and extract image data
                tempCtx.clearRect(0, 0, canvasWidth, canvasHeight);
                tempCtx.drawImage(img, 0, 0);
                const drawingData = tempCtx.getImageData(
                  0,
                  0,
                  canvasWidth,
                  canvasHeight
                );

                pages.push({
                  id: pageId,
                  drawingData: drawingData,
                  history: [],
                  currentStep: -1,
                });

                resolve();
              };
              img.onerror = () => {
                console.warn(`Page image not found: page-${pageId}.png`);
                pages.push({
                  id: pageId,
                  drawingData: null,
                  history: [],
                  currentStep: -1,
                });
                resolve();
              };
            });
          }
        }

        // Setup canvas layers
        setupNotebookBackground(); // ‚Üê draw notebook lines on background canvas
        switchToPage(0); // ‚Üê restore drawing from loaded page
        updatePageControls();
        updateThumbnails();
      }

      // Draw notebook lines background
      function setupNotebookBackground() {
        backgroundCtx.clearRect(0, 0, canvasWidth, canvasHeight);
        backgroundCtx.fillStyle = "#fff";
        backgroundCtx.fillRect(0, 0, canvasWidth, canvasHeight);

        backgroundCtx.strokeStyle = "#ddd";

        for (let y = lineSpacing; y < canvasHeight; y += lineSpacing) {
          backgroundCtx.beginPath();
          backgroundCtx.moveTo(0, y);
          backgroundCtx.lineTo(canvasWidth, y);
          backgroundCtx.stroke();
        }
      }

      // Page management functions
      function addNewPage() {
        const newPageId = Math.max(...pages.map((p) => p.id)) + 1;
        pages.push({
          id: newPageId,
          drawingData: null,
          history: [],
          currentStep: -1,
        });

        // Switch to new page
        switchToPage(pages.length - 1);
        updatePageControls();
        updateThumbnails();
      }

      function duplicatePage() {
        const currentPage = pages[currentPageIndex];
        const newPageId = Math.max(...pages.map((p) => p.id)) + 1;

        // Create a copy of current page's drawing data
        const duplicatedData = currentPage.drawingData
          ? drawingCtx.createImageData(currentPage.drawingData)
          : null;

        const newPage = {
          id: newPageId,
          drawingData: duplicatedData,
          history: [],
          currentStep: -1,
        };

        pages.splice(currentPageIndex + 1, 0, newPage);
        switchToPage(currentPageIndex + 1);
        updatePageControls();
        updateThumbnails();
      }

      async function deletePage() {
        const page = pages[currentPageIndex];
        if (!page) return;

        const confirmDelete = confirm(
          `Delete page ${page.id}? This cannot be undone.`
        );
        if (!confirmDelete) return;

        const response = await fetch(
          `/api/book/${bookId}/page/${page.id}/delete/`,
          {
            method: "DELETE",
          }
        );

        const result = await response.json();

        if (response.ok) {
          // Remove from frontend memory
          pages.splice(currentPageIndex, 1);

          if (pages.length === 0) {
            pages.push({
              id: 1,
              drawingData: null,
              history: [],
              currentStep: -1,
            });
          }

          // Go to first page or previous
          currentPageIndex = Math.min(currentPageIndex, pages.length - 1);

          loadCurrentPageDrawing();
          updatePageControls();
          updateThumbnails();

          alert(`Page ${result.page_id} deleted.`);
        } else {
          alert(`Error: ${result.error || "Failed to delete page"}`);
        }
      }

      function switchToPage(pageIndex) {
        if (pageIndex < 0 || pageIndex >= pages.length) return;

        // Save current page state before switching
        saveCurrentPageDrawing();

        // Switch to new page
        currentPageIndex = pageIndex;
        loadCurrentPageDrawing();
        updatePageControls();
        updateThumbnails();
      }

      async function saveCurrentPageDrawing() {
        if (pages[currentPageIndex]) {
          const canvas = document.createElement("canvas");
          canvas.width = canvasWidth;
          canvas.height = canvasHeight;
          const ctx = canvas.getContext("2d");
          ctx.drawImage(backgroundCanvas, 0, 0);
          ctx.drawImage(drawingCanvas, 0, 0);

          const dataURL = canvas.toDataURL("image/png");

          await fetch(`/api/book/${bookId}/save-page/`, {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
              "X-CSRFToken":
                document.querySelector("[name=csrfmiddlewaretoken]")?.value ||
                "",
            },
            body: JSON.stringify({
              page_id: pages[currentPageIndex].id,
              image_data: dataURL,
            }),
          });

          pages[currentPageIndex].drawingData = drawingCtx.getImageData(
            0,
            0,
            canvasWidth,
            canvasHeight
          );
        }
      }

      function loadCurrentPageDrawing() {
        // Clear canvas
        drawingCtx.clearRect(0, 0, canvasWidth, canvasHeight);

        // Load page data if it exists
        const currentPage = pages[currentPageIndex];
        if (currentPage && currentPage.drawingData) {
          drawingCtx.putImageData(currentPage.drawingData, 0, 0);
        }
      }

      function saveCurrentPageState() {
        const currentPage = pages[currentPageIndex];
        if (!currentPage) return;

        // If we're not at the end of the history, remove everything after current step
        if (currentPage.currentStep < currentPage.history.length - 1) {
          currentPage.history = currentPage.history.slice(
            0,
            currentPage.currentStep + 1
          );
        }

        // Save current state
        currentPage.history.push(
          drawingCtx.getImageData(0, 0, canvasWidth, canvasHeight)
        );
        currentPage.currentStep = currentPage.history.length - 1;

        // Also save to page data
        saveCurrentPageDrawing();
      }

      function undoCurrentPage() {
        const currentPage = pages[currentPageIndex];
        if (!currentPage) return;

        if (currentPage.currentStep > 0) {
          currentPage.currentStep--;
          drawingCtx.putImageData(
            currentPage.history[currentPage.currentStep],
            0,
            0
          );
          saveCurrentPageDrawing();
        } else if (currentPage.currentStep === 0) {
          drawingCtx.clearRect(0, 0, canvasWidth, canvasHeight);
          saveCurrentPageDrawing();
        }
        updateThumbnails();
      }

      function updatePageControls() {
        currentPageInput.value = currentPageIndex + 1;
        totalPagesSpan.textContent = pages.length;

        prevPageBtn.disabled = currentPageIndex === 0;
        nextPageBtn.disabled = currentPageIndex === pages.length - 1;
        deletePageBtn.disabled = pages.length <= 1;
      }

      function updateThumbnails() {
        pageThumbnailsContainer.innerHTML = "";

        pages.forEach((page, index) => {
          const thumbnailDiv = document.createElement("div");
          thumbnailDiv.className = `page-thumbnail ${
            index === currentPageIndex ? "active" : ""
          }`;

          const thumbnailCanvas = document.createElement("canvas");
          thumbnailCanvas.width = 80;
          thumbnailCanvas.height = 100;
          const thumbnailCtx = thumbnailCanvas.getContext("2d");

          // Draw background
          thumbnailCtx.fillStyle = "white";
          thumbnailCtx.fillRect(0, 0, 80, 100);

          // Draw simplified notebook lines
          thumbnailCtx.strokeStyle = "#a0c0e8";
          thumbnailCtx.lineWidth = 0.5;
          for (let y = 3; y < 100; y += 3) {
            thumbnailCtx.beginPath();
            thumbnailCtx.moveTo(0, y);
            thumbnailCtx.lineTo(80, y);
            thumbnailCtx.stroke();
          }

          // Draw margin
          thumbnailCtx.strokeStyle = "#ff9999";
          thumbnailCtx.beginPath();
          thumbnailCtx.moveTo(6, 0);
          thumbnailCtx.lineTo(6, 100);
          thumbnailCtx.stroke();

          // Draw page content if exists
          if (page.drawingData) {
            const tempCanvas = document.createElement("canvas");
            tempCanvas.width = canvasWidth;
            tempCanvas.height = canvasHeight;
            const tempCtx = tempCanvas.getContext("2d");
            tempCtx.putImageData(page.drawingData, 0, 0);

            thumbnailCtx.drawImage(tempCanvas, 0, 0, 80, 100);
          }

          const pageNumber = document.createElement("div");
          pageNumber.className = "page-number";
          pageNumber.textContent = index + 1;

          const deleteBtn = document.createElement("button");
          deleteBtn.className = "delete-page";
          deleteBtn.innerHTML = "√ó";
          deleteBtn.onclick = (e) => {
            e.stopPropagation();
            if (pages.length > 1) {
              pages.splice(index, 1);
              if (currentPageIndex >= index && currentPageIndex > 0) {
                currentPageIndex--;
              }
              if (currentPageIndex >= pages.length) {
                currentPageIndex = pages.length - 1;
              }
              switchToPage(currentPageIndex);
              updatePageControls();
              updateThumbnails();
            }
          };

          thumbnailDiv.appendChild(thumbnailCanvas);
          thumbnailDiv.appendChild(pageNumber);
          if (pages.length > 1) {
            thumbnailDiv.appendChild(deleteBtn);
          }

          thumbnailDiv.onclick = () => switchToPage(index);
          pageThumbnailsContainer.appendChild(thumbnailDiv);
        });
      }

      // Event listeners for drawing
      drawingCanvas.addEventListener("mousedown", startDrawing);
      drawingCanvas.addEventListener("mousemove", draw);
      drawingCanvas.addEventListener("mouseup", stopDrawing);
      drawingCanvas.addEventListener("mouseout", stopDrawing);

      // Page control event listeners
      prevPageBtn.addEventListener("click", () => {
        if (currentPageIndex > 0) {
          switchToPage(currentPageIndex - 1);
        }
      });

      nextPageBtn.addEventListener("click", () => {
        if (currentPageIndex < pages.length - 1) {
          switchToPage(currentPageIndex + 1);
        }
      });

      addPageBtn.addEventListener("click", addNewPage);
      duplicatePageBtn.addEventListener("click", duplicatePage);
      deletePageBtn.addEventListener("click", deletePage);

      currentPageInput.addEventListener("change", (e) => {
        const pageNum = parseInt(e.target.value);
        if (pageNum >= 1 && pageNum <= pages.length) {
          switchToPage(pageNum - 1);
        } else {
          e.target.value = currentPageIndex + 1;
        }
      });

      exportAllBtn.addEventListener("click", exportAllPages);

      // Tool selection
      penTool.addEventListener("click", () => {
        setActiveTool("pen");
      });

      eraserTool.addEventListener("click", () => {
        setActiveTool("eraser");
      });

      clearBtn.addEventListener("click", clearCurrentPage);
      downloadBtn.addEventListener("click", downloadCurrentPage);
      undoBtn.addEventListener("click", undoCurrentPage);
      convertBtn.addEventListener("click", convertAllPagesLines);
      extractTextBtn.addEventListener("click", extractTextFromLines);

      // Tool options
      penSize.addEventListener("input", () => {
        sizeDisplay.textContent = `${penSize.value}px`;
      });

      // Keyboard shortcuts
      document.addEventListener("keydown", (e) => {
        if (e.ctrlKey && e.key === "z") {
          e.preventDefault();
          undoCurrentPage();
        } else if (e.key === "ArrowLeft" && e.ctrlKey) {
          e.preventDefault();
          if (currentPageIndex > 0) switchToPage(currentPageIndex - 1);
        } else if (e.key === "ArrowRight" && e.ctrlKey) {
          e.preventDefault();
          if (currentPageIndex < pages.length - 1)
            switchToPage(currentPageIndex + 1);
        }
      });

      // Drawing functions (unchanged from original)
      function startDrawing(e) {
        isDrawing = true;
        [lastX, lastY] = getMousePos(drawingCanvas, e);

        drawingCtx.beginPath();
        drawingCtx.moveTo(lastX, lastY);
        drawingCtx.lineTo(lastX, lastY);
        drawingCtx.stroke();
      }

      function draw(e) {
        if (!isDrawing) return;

        const [currentX, currentY] = getMousePos(drawingCanvas, e);

        drawingCtx.beginPath();
        drawingCtx.moveTo(lastX, lastY);
        drawingCtx.lineTo(currentX, currentY);

        if (currentTool === "pen") {
          drawingCtx.globalCompositeOperation = "source-over";
          drawingCtx.strokeStyle = penColor.value;
          drawingCtx.lineWidth = parseInt(penSize.value);
        } else if (currentTool === "eraser") {
          drawingCtx.globalCompositeOperation = "destination-out";
          drawingCtx.lineWidth = parseInt(penSize.value) * 2;
        }

        drawingCtx.stroke();
        drawingCtx.globalCompositeOperation = "source-over"; // Reset

        lastX = currentX;
        lastY = currentY;
      }

      function stopDrawing() {
        if (isDrawing) {
          isDrawing = false;
          saveCurrentPageState();
          updateThumbnails();
        }
      }

      function getMousePos(canvas, evt) {
        const rect = canvas.getBoundingClientRect();

        const scaleX = canvas.width / rect.width;
        const scaleY = canvas.height / rect.height;

        return [
          (evt.clientX - rect.left) * scaleX,
          (evt.clientY - rect.top) * scaleY,
        ];
      }

      function setActiveTool(tool) {
        currentTool = tool;

        penTool.classList.toggle("active", tool === "pen");
        eraserTool.classList.toggle("active", tool === "eraser");

        toolStatus.textContent = `Current tool: ${
          tool.charAt(0).toUpperCase() + tool.slice(1)
        }`;
      }

      function clearCurrentPage() {
        drawingCtx.clearRect(0, 0, canvasWidth, canvasHeight);
        saveCurrentPageState();
        updateThumbnails();
      }

      function downloadCurrentPage() {
        const tempCanvas = document.createElement("canvas");
        tempCanvas.width = canvasWidth;
        tempCanvas.height = canvasHeight;
        const tempCtx = tempCanvas.getContext("2d");

        tempCtx.drawImage(drawingCanvas, 0, 0);

        const link = document.createElement("a");
        link.download = `notebook-page-${currentPageIndex + 1}.png`;
        link.href = tempCanvas.toDataURL("image/png");
        link.click();
      }

      function exportAllPages() {
        const zip = new JSZip();

        pages.forEach((page, index) => {
          const tempCanvas = document.createElement("canvas");
          tempCanvas.width = canvasWidth;
          tempCanvas.height = canvasHeight;
          const tempCtx = tempCanvas.getContext("2d");
          // Draw page content
          if (page.drawingData) {
            tempCtx.putImageData(page.drawingData, 0, 0);
          }

          const dataURL = tempCanvas.toDataURL("image/png");
          const base64Data = dataURL.split(",")[1];
          zip.file(`page-${index + 1}.png`, base64Data, { base64: true });
        });

        zip.generateAsync({ type: "blob" }).then(function (content) {
          const link = document.createElement("a");
          link.href = URL.createObjectURL(content);
          link.download = "notebook-all-pages.zip";
          link.click();
        });
      }

      // Convert and extract functions (adapted for current page)
      async function convertAllPagesLines() {
        saveCurrentPageDrawing();
        convertStatus.textContent = " | Segmenting lines...";
        convertBtn.disabled = true;

        try {
          // Call the new segmentation API
          const csrfToken =
            document.querySelector("[name=csrfmiddlewaretoken]")?.value ||
            document
              .querySelector("meta[name=csrf-token]")
              ?.getAttribute("content");

          const response = await fetch("/notebook/segment-lines/", {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
              "X-CSRFToken": csrfToken,
            },
            body: JSON.stringify({
              book_id: bookId,
            }),
          });

          if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
          }

          const result = await response.json();
          console.log("Segmentation result:", result);

          lastConversionData = {
            bookid: bookId,
            session_id: result.session_id,
            timestamp: result.timestamp,
          };

          extractTextBtn.disabled = false;
          convertStatus.textContent = ` | ${result.total_lines} lines segmented!`;
        } catch (error) {
          console.error("Error segmenting lines:", error);
          convertStatus.textContent = " | Segmentation failed!";
        } finally {
          convertBtn.disabled = false;
          setTimeout(() => {
            convertStatus.textContent = "";
          }, 5000);
        }
      }

      // Backend communication functions (unchanged)
      async function saveLinesToServer(images) {
        const csrfToken =
          document.querySelector("[name=csrfmiddlewaretoken]")?.value ||
          document
            .querySelector("meta[name=csrf-token]")
            ?.getAttribute("content");

        const response = await fetch("/notebook/save-lines/", {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
            "X-CSRFToken": csrfToken,
          },
          body: JSON.stringify({
            images: images,
          }),
        });

        if (!response.ok) {
          throw new Error(`HTTP error! status: ${response.status}`);
        }

        const result = await response.json();
        console.log("Lines saved successfully:", result);
        return result;
      }

      async function extractTextFromLines() {
        if (!lastConversionData) {
          convertStatus.textContent = " | Please convert page lines first!";
          setTimeout(() => (convertStatus.textContent = ""), 3000);
          return;
        }

        convertStatus.textContent = " | Extracting text...";
        extractTextBtn.disabled = true;

        try {
          const csrfToken =
            document.querySelector("[name=csrfmiddlewaretoken]")?.value ||
            document
              .querySelector("meta[name=csrf-token]")
              ?.getAttribute("content");

          const response = await fetch("/notebook/extract-text/", {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
              "X-CSRFToken": csrfToken,
            },
            body: JSON.stringify(lastConversionData),
          });

          if (!response.ok) {
            const errorData = await response.json();
            throw new Error(
              errorData.error || `HTTP error! status: ${response.status}`
            );
          }

          const blob = await response.blob();

          const url = window.URL.createObjectURL(blob);
          const link = document.createElement("a");
          link.href = url;
          link.download = `extracted_text_page_${lastConversionData.page_number}_${lastConversionData.timestamp}_${lastConversionData.session_id}.txt`;
          document.body.appendChild(link);
          link.click();
          document.body.removeChild(link);
          window.URL.revokeObjectURL(url);

          convertStatus.textContent =
            " | Text extracted and downloaded successfully!";
        } catch (error) {
          console.error("Error extracting text:", error);
          convertStatus.textContent = ` | Text extraction failed: ${error.message}`;
        } finally {
          extractTextBtn.disabled = false;
          setTimeout(() => {
            convertStatus.textContent = "";
          }, 5000);
        }
      }
      // Convert touch to mouse-like drawing
      drawingCanvas.addEventListener(
        "touchstart",
        (e) => {
          if (e.touches.length > 1) return; // üëà Prevent draw if multitouch
          e.preventDefault();
          const touch = e.touches[0];
          const simulatedEvent = new MouseEvent("mousedown", {
            clientX: touch.clientX,
            clientY: touch.clientY,
          });
          drawingCanvas.dispatchEvent(simulatedEvent);
        },
        { passive: false }
      );

      drawingCanvas.addEventListener(
        "touchmove",
        (e) => {
          if (e.touches.length > 1) return; // üëà Prevent draw if multitouch
          e.preventDefault();
          const touch = e.touches[0];
          const simulatedEvent = new MouseEvent("mousemove", {
            clientX: touch.clientX,
            clientY: touch.clientY,
          });
          drawingCanvas.dispatchEvent(simulatedEvent);
        },
        { passive: false }
      );

      drawingCanvas.addEventListener(
        "touchend",
        (e) => {
          if (e.touches.length > 0) return; // üëà only end if all fingers off
          e.preventDefault();
          const simulatedEvent = new MouseEvent("mouseup", {});
          drawingCanvas.dispatchEvent(simulatedEvent);
        },
        { passive: false }
      );

      const toolbar = document.querySelector(".toolbar");
      const toggleBtn = document.getElementById("toggle-toolbar-btn");
      const canvasContainer = document.querySelector(".canvas-container");

      toggleBtn.addEventListener("click", () => {
        toolbar.classList.toggle("hidden");
        canvasContainer.classList.toggle("full");
        toggleBtn.textContent = toolbar.classList.contains("hidden")
          ? "üõ†Ô∏è Show Tools"
          : "üõ†Ô∏è Hide Tools";
      });
      const topMenu = document.getElementById("top-menu");
      const toggleTopMenuBtn = document.getElementById("toggle-top-menu-btn");

      toggleTopMenuBtn.addEventListener("click", () => {
        const isHidden = topMenu.classList.toggle("hidden");
        toggleTopMenuBtn.textContent = isHidden ? "‚ò∞ Menu" : "‚úñÔ∏è Close";
      });
      function resizeCanvasFullscreen() {
        const screenW = window.innerWidth;
        const screenH = window.innerHeight;

        drawingCanvas.width = screenW;
        drawingCanvas.height = screenH;
        backgroundCanvas.width = screenW;
        backgroundCanvas.height = screenH;

        drawingCanvas.style.width = screenW + "px";
        drawingCanvas.style.height = screenH + "px";
        backgroundCanvas.style.width = screenW + "px";
        backgroundCanvas.style.height = screenH + "px";
      }
      document.addEventListener("dblclick", function (e) {
        e.preventDefault();
      });

      // Initialize the notebook
      initializeNotebook();
      resizeCanvasForDisplay();
      window.addEventListener("resize", resizeCanvasForDisplay);
      resizeCanvasFullscreen();
      window.addEventListener("resize", resizeCanvasFullscreen);
    </script>
  </body>
</html>
